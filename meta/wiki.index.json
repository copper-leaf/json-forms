{
  "ownKey": "wiki",
  "childrenPages": {"wiki": {
    "ownKey": "wiki",
    "childrenPages": {
      "changelog": {
        "ownKey": "changelog",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/kotlin-json-forms",
            "fileName": "changelog",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/kotlin-json-forms/wiki/changelog"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/kotlin-json-forms",
            "fileName": "usage-guide",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/kotlin-json-forms/wiki/usage-guide"
          },
          "description": "",
          "title": "Changelog",
          "content": ""
        }]
      },
      "usage-guide": {
        "ownKey": "usage-guide",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/kotlin-json-forms",
            "fileName": "usage-guide",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/kotlin-json-forms/wiki/usage-guide"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://copper-leaf.github.io/kotlin-json-forms",
            "fileName": "changelog",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://copper-leaf.github.io/kotlin-json-forms/wiki/changelog"
          },
          "description": "",
          "title": "Usage Guide",
          "content": "<h1 id=\"usage-guide\"><a href=\"#usage-guide\" id=\"usage-guide\" class=\"anchor\"><\/a>Usage Guide<\/h1>\n<p>This library aims to re-implement the same JSON Schema-based forms from the\n<a href=\"https://jsonforms.io/docs\">Javascript JSON Forms library<\/a>. As such, much of the documentation from that site will be\nvalid here, in particular the values of anything in JSON files. All the <a href=\"https://jsonforms.io/examples/basic\">examples<\/a>\nfrom that site are also valid form definitions here, and you can see examples in action for Desktop and Android targets\n<a href=\"https://github.com/copper-leaf/kotlin-json-forms\">here<\/a>. Some specific widgets from those examples may not render the\nsame as not all UI widgets have been implemented yet, but these features are planned.<\/p>\n<h1 id=\"supported-targets\"><a href=\"#supported-targets\" id=\"supported-targets\" class=\"anchor\"><\/a>Supported targets<\/h1>\n<p>Kotlin Json Forms currently supports Compose Material for Desktop and Android, but most of this project is built using\ncommon Kotlin APIs which should be able to support other UI targets. In cases where platform-specific functionality or\ndependencies are needed, they are implemented with <code>expect/actual<\/code> declarations to eventually aid in adopting other\ntargets, such as Compose for Web.<\/p>\n<h1 id=\"dependencies\"><a href=\"#dependencies\" id=\"dependencies\" class=\"anchor\"><\/a>Dependencies<\/h1>\n<p>This library is based on the JSON models and (de)serialization capabilities from\n<a href=\"https://github.com/Kotlin/kotlinx.serialization\">Kotlinx Serialization<\/a>, though knowledge of that library is not\nstrictly necessary to use Kotlin Json Forms, nor is the Serialization gradle plugin. It only uses the runtime library.<\/p>\n<p>Additionally, schema validation is supported individually for each platform, because schema validator libraries are\nlarge and too complex to reimplement for this project, so it's easier to find appropriate libraries on each platform as\nneeded, and use them through <code>expect/actual<\/code> declarations.\n<a href=\"https://github.com/pwall567/json-kotlin-schema\">json-kotlin-schema<\/a> is the library currently in use for Compose Desktop\nand Android targets.<\/p>\n<h1 id=\"basic-usage\"><a href=\"#basic-usage\" id=\"basic-usage\" class=\"anchor\"><\/a>Basic Usage<\/h1>\n<p>The simplest usage of this library looks like this:<\/p>\n<pre><code class=\"language-kotlin\">@Composable\nfun RenderFormPreview(\n    formStore: FormSavedStateAdapter.Store\n) {\n    \n}\n<\/code><\/pre>\n<p><code>FormSavedStateAdapter.Store<\/code> is an interface that must be implemented by you, and is how the Form schema gets\npopulated, and where form state is saved and loaded from. All values returned from the Store are instances of\n<code>kotlinx.serialization.json.JsonElement<\/code>, which is the parsed DOM-like structure of JSON from the Kotlinx Serialization\nlibrary. This means that you're not actually locked into using JSON Strings for the schemas of this library, you're free\nto parse the input in another format and convert that format's in-memory representation to <code>JsonElement<\/code> if you need. An\nexample would be writing your schemas in <code>.yaml<\/code> files instead of <code>.json<\/code>.<\/p>\n<p>Since the library works with the already-parsed JSON models, you also have the flexibility to work entirely with\nin-memory if you want, to avoid the wasted overhead of continually parsing and serializing those elements to Strings.<\/p>\n<h1 id=\"form-state\"><a href=\"#form-state\" id=\"form-state\" class=\"anchor\"><\/a>Form State<\/h1>\n<p>Form data is managed with the MVI pattern with the\n<a href=\"https://github.com/copper-leaf/ballast\">Ballast state management library<\/a>. The form schemas and the associated data is\nmanaged centrally in a ViewModel class, and any changes to the state are sent through a <code>StateFlow<\/code> to be collected by\nthe UI and updated. Anytime any field of the form's data changes, the entire form will be updated accordingly, and all\nrules will be re-evaluated.<\/p>\n<p>The Form ViewModel manages a <code>StateFlow<\/code> of <code>FormContract.State<\/code>, which holds onto a lot of useful data which may be\nneeded by the form UI renderer, but may be useful for custom UI elements as well. In particular, it keeps a copy of the\noriginal data separately from the data that's currently in the UI, and has properties available to let you know whether\nthe data has been changed, or whether any individual control widget in the UI has been interacted with or its value\nchanged.<\/p>\n<p>The form's initial configuration is provided to the ViewModel with <code>FormSavedStateAdapter.Store<\/code>, which should be\ncreated by you, returning JSON Strings of the Schema and UI schema to the ViewModel. It also is the mechanism by which\nyou will be notified when the form's data has changed. You can also change when the form state will be sent to the\nStore by configuring the <code>FormSavedStateAdapter<\/code>'s <code>SaveType<\/code> when you provide it to the ViewModel. The <code>SaveType<\/code> can\nbe one of the following values:<\/p>\n<ul>\n<li><code>SaveType.OnValidChange<\/code>: After any change is made to the form data, if the updated data is valid according to the\nprovided JSON Schema, then the form will be saved automatically.<\/li>\n<li><code>SaveType.OnAnyChange<\/code>: After any change is made to the form data, then the form will be saved automatically, even if\nit is not valid against the provided JSON Schema<\/li>\n<li><code>SaveType.OnCommit<\/code>: The form will never save itself automatically, but will only be saved when the user explicitly\nchooses to save the form with some button in the UI. Kotlin Json Forms has a built-in submit button which can be added\nto the UI Schema definition with an element like this: <code>{ &quot;type&quot;: &quot;Button&quot;, &quot;options&quot;: { &quot;action&quot;: &quot;submit&quot; } }<\/code>, but\nyou are free to build your own custom UI element outside of the form which calls\n<code>vm.trySend(FormContract.Inputs.CommitChanges)<\/code> to accomplish the same functionality.<\/li>\n<\/ul>\n<h1 id=\"supported-features\"><a href=\"#supported-features\" id=\"supported-features\" class=\"anchor\"><\/a>Supported Features<\/h1>\n<h2 id=\"ui-elements\"><a href=\"#ui-elements\" id=\"ui-elements\" class=\"anchor\"><\/a>UI Elements<\/h2>\n<p>UI Elements are defined in the UI schema, and control how the form is physically laid out and rendered on the page. The\ntable below shows the different controls that are currently implemented or will be soon.<\/p>\n<table>\n<thead>\n<tr><th>UI Element<\/th><th>Element Type in UI Schema<\/th><th>Other UI Schema config<\/th><th>Supported<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Render child elements in a Compose <code>Column<\/code><\/td><td><code>&quot;type&quot;: &quot;VerticalLayout&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Render child elements in a Compose <code>Row<\/code><\/td><td><code>&quot;type&quot;: &quot;HorizontalLayout&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Render a Control according to the referenced field type (see next section)<\/td><td><code>&quot;type&quot;: &quot;Control&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>A simple Label<\/td><td><code>&quot;type&quot;: &quot;Label&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Group related elements in a card<\/td><td><code>&quot;type&quot;: &quot;Group&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Set up a tabbed view. Each tab will be shown/hidden according to the Rule of the element itself<\/td><td><code>&quot;type&quot;: &quot;Categorization&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>One tab as a child of <code>Categorization<\/code><\/td><td><code>&quot;type&quot;: &quot;Category&quot;<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>A Submit button to commit form changes. Only visible when using <code>SaveType.OnCommit<\/code><\/td><td><code>&quot;type&quot;: &quot;Button&quot;<\/code><\/td><td><code>&quot;options&quot;: { &quot;action&quot;: &quot;submit&quot; }<\/code><\/td><td>Yes<\/td><\/tr>\n<tr><td>A checkbox to show/hide debug info<\/td><td><code>&quot;type&quot;: &quot;Button&quot;<\/code><\/td><td><code>&quot;options&quot;: { &quot;action&quot;: &quot;toggleDebug&quot; }<\/code><\/td><td>Yes<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"controls\"><a href=\"#controls\" id=\"controls\" class=\"anchor\"><\/a>Controls<\/h2>\n<p>Controls are defined with an element in the UI Schema with <code>&quot;type&quot;: &quot;Control&quot;<\/code> and a <code>scope<\/code> property that is a JSON\nPointer to a field in the form Schema. The field type in the Schema defines the control widget that is rendered, but\nsome field types may be rendered differently based on a combination of properties in both the Schema and the UI Schema.<\/p>\n<p>There are several controls available in the original JavaScript library that are not available in Kotlin Json Forms yet,\nbut a goal is to have all controls from that library fully working here soon. The table below shows the different\ncontrols that are currently implemented or will be soon.<\/p>\n<table>\n<thead>\n<tr><th>UI Control<\/th><th>Field Type in Schema<\/th><th>Other Schema config<\/th><th>Other UI Schema config<\/th><th>Supported<\/th><\/tr>\n<\/thead>\n<tbody>\n<tr><td>Normal text field<\/td><td><code>string<\/code><\/td><td> <\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Rich text field editor<\/td><td><code>string<\/code><\/td><td> <\/td><td><code>&quot;options&quot;: { &quot;richText&quot;: true }<\/code><\/td><td>Partial, doesn't actually update data<\/td><\/tr>\n<tr><td>Code text field editor<\/td><td><code>string<\/code><\/td><td> <\/td><td><code>&quot;options&quot;: { &quot;codeEditor&quot;: true, &quot;lang&quot;: &quot;file extension (optional, defaults to generic markup)&quot; }<\/code><\/td><td>Yes<\/td><\/tr>\n<tr><td>Text field with dropdown menu<\/td><td><code>string<\/code><\/td><td><code>&quot;enum&quot;: [...]<\/code><\/td><td> <\/td><td>Partial, dropdown is clunky<\/td><\/tr>\n<tr><td>Text field with Radio Buttons<\/td><td><code>string<\/code><\/td><td><code>&quot;enum&quot;: [...]<\/code><\/td><td><code>&quot;options&quot;: { &quot;format&quot;: &quot;radio&quot; }<\/code><\/td><td>Yes<\/td><\/tr>\n<tr><td>Text field with dropdown menu<\/td><td><code>string<\/code><\/td><td><code>&quot;oneOf&quot;: [{}, {}]<\/code><\/td><td> <\/td><td>Partial, dropdown is clunky<\/td><\/tr>\n<tr><td>Text field with Radio Buttons<\/td><td><code>string<\/code><\/td><td><code>&quot;oneOf&quot;: [{}, {}]<\/code><\/td><td><code>&quot;options&quot;: { &quot;format&quot;: &quot;radio&quot; }<\/code><\/td><td>Yes<\/td><\/tr>\n<tr><td>Text field with Date Picker<\/td><td><code>string<\/code><\/td><td><code>&quot;format&quot;: &quot;date&quot;<\/code><\/td><td> <\/td><td>No<\/td><\/tr>\n<tr><td>Text field with Time Picker<\/td><td><code>string<\/code><\/td><td><code>&quot;format&quot;: &quot;time&quot;<\/code><\/td><td> <\/td><td>No<\/td><\/tr>\n<tr><td>Text field with DateTime Picker<\/td><td><code>string<\/code><\/td><td><code>&quot;format&quot;: &quot;datetime&quot;<\/code><\/td><td> <\/td><td>No<\/td><\/tr>\n<tr><td>Text field with up/down buttons<\/td><td><code>integer<\/code><\/td><td> <\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Text field with up/down buttons<\/td><td><code>number<\/code><\/td><td> <\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Checkbox<\/td><td><code>boolean<\/code><\/td><td> <\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Switch<\/td><td><code>boolean<\/code><\/td><td> <\/td><td><code>&quot;options&quot;: { &quot;toggle&quot;: true }<\/code><\/td><td>Yes<\/td><\/tr>\n<tr><td>Multi-select Checkboxes<\/td><td><code>array<\/code><\/td><td><code>uniqueItems: true, items: {&quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [] }<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Multi-select Checkboxes<\/td><td><code>array<\/code><\/td><td><code>uniqueItems: true, items: {&quot;oneOf&quot;: [{}, {}] }<\/code><\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Render all properties of the object as fields<\/td><td><code>object<\/code><\/td><td> <\/td><td> <\/td><td>Yes<\/td><\/tr>\n<tr><td>Add/remove items from the array (including nested arrays)<\/td><td><code>array<\/code><\/td><td> <\/td><td> <\/td><td>Partial, UI is ugly<\/td><\/tr>\n<\/tbody>\n<\/table>\n<h2 id=\"validation\"><a href=\"#validation\" id=\"validation\" class=\"anchor\"><\/a>Validation<\/h2>\n<p>Each control rendered in the UI will check for validation error messages and display them in the UI. JSON Schema\nvalidation is very complex, and the messaged displayed in the UI come directly from the platform's validation library,\nwhich may not be the most user-friendly. At this time, it is not a goal to provide more user-friendly or localized\nerror messages.<\/p>\n<h1 id=\"roadmap\"><a href=\"#roadmap\" id=\"roadmap\" class=\"anchor\"><\/a>Roadmap<\/h1>\n<p>This is a list of features planned for this library. None of them are guaranteed, all of them are open for contribution.<\/p>\n<ul>\n<li>Improve rich-text editor\n<ul>\n<li>Contribute improvements to the upstream library for <a href=\"https://github.com/Wavesonics/richtext-compose-multiplatform\">richtext-compose-multiplatform<\/a><\/li>\n<li>Improve toolbar and keyboard shortcuts<\/li>\n<li>Support saving/restoring rich text field state to/from HTML and Markdown<\/li>\n<li>Allow the user to switch between the rich-text editor, and editing the markup directly<\/li>\n<li>When editing markup directly, allow user to choose whether to show a rendered preview of the rich text<\/li>\n<\/ul>\n<\/li>\n<li>Add code editor widget\n<ul>\n<li>Potentially based on <a href=\"https://github.com/Qawaz/compose-code-editor\">this library<\/a>, if it would move its dependencies to MavenCentral<\/li>\n<\/ul>\n<\/li>\n<li>Improve UX of dropdown-based widgets<\/li>\n<li>Support date/time pickers\n<ul>\n<li>Ideally, these would use the native picker dialogs on Android, and custom-built ones for Desktop<\/li>\n<\/ul>\n<\/li>\n<li>Add UI elements to display refs to properties, or computed expressions\n<ul>\n<li>Use <a href=\"https://github.com/copper-leaf/trellis\">trellis<\/a> for building the expression DSL here<\/li>\n<\/ul>\n<\/li>\n<li>Improve UX of array widgets\n<ul>\n<li>would be nice to have list, master/detail, and table views for array-of-object controls<\/li>\n<\/ul>\n<\/li>\n<li>Improve error messages\n<ul>\n<li>See if there's a way to map the error messages of the validator libs to common strings (especially ones that could be localized)<\/li>\n<li>Add a way to provide custom additional error messages (such as coming from an API after submitting the form)<\/li>\n<\/ul>\n<\/li>\n<li>Support <code>readonly<\/code> flag\n<ul>\n<li>Globally on the entire form (set via FormContract.State)<\/li>\n<li>On any individual Control<\/li>\n<li>On a property within the JSON Schema<\/li>\n<\/ul>\n<\/li>\n<li>Support <code>definitions<\/code> so that object/array controls can use <code>oneOf<\/code>, <code>anyOf<\/code>, or <code>allOf<\/code> with <code>$ref<\/code> to the definitions<\/li>\n<li>Automatically move focus between controls with tab on desktop<\/li>\n<\/ul>\n"
        }]
      }
    },
    "ownPages": [{
      "reference": {
        "path": "",
        "baseUrl": "https://copper-leaf.github.io/kotlin-json-forms",
        "fileName": "wiki",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://copper-leaf.github.io/kotlin-json-forms/wiki"
      },
      "description": "",
      "title": "Wiki",
      "content": "<html>\n <head><\/head>\n <body>\n  <ul> \n   <li><a href=\"https://copper-leaf.github.io/kotlin-json-forms/wiki/usage-guide\">Usage Guide<\/a><\/li> \n   <li><a href=\"https://copper-leaf.github.io/kotlin-json-forms/wiki/changelog\">Changelog<\/a><\/li> \n  <\/ul> \n <\/body>\n<\/html>\n"
    }]
  }}
}